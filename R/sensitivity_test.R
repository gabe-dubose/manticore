
#' Perform random tree congruence test 
#' 
#' @description Run a sensitivity test on random tree congruence test
#' results. This function tests how sensitive RTC test results
#' are to variation in congruence estimates (uncertainty). To 
#' accomplish this, a distribution of congruence values are 
#' generated by iteratively using subtree pruning (SPR) and regrafting to mutate
#' the original input trees. The congruence distribution is then compared
#' against the null model, and an integrated P(Null >= Observed) values 
#' is calculated across the congruence distribution.
#' The extent of SPR is increased to introduce greater variation. 
#' 
#' @param reference.tree Path to reference tree file, or string in Newick format
#' @param comparison.tree Path to comparison tree file, or string in Newick format
#' @param null.congruence.model Null model generated by rtc.test function
#' @param metric Congruence metric specified for null model generation
#' @param spr.proportions Vector of proportions of tree size to subtree prune and regraft: default = seq(0, 0.5, by=0.05)
#' @param iterations Number of times to perform SPR on input trees to generate congruence distribution: default = 100
#' 
#' @return Function returns a dataframe containing the integrated P(Null >= Observed)
#' (integrated.p column) as a function of SPR proportion (prop.dive column).
#' 
#' @export
rtc.sensitivity.test <- function(reference.tree, comparison.tree, null.congruence.model, 
                                 metric, spr.proportions = seq(0, 0.5, by=0.05), 
                                 iterations=100){
  
  # initialize vector to store integrated p.values
  p.ints <- c()
  
  # load trees 
  reference.tree <- ape::read.tree(text=reference.tree)
  comparison.tree <- ape::read.tree(text=comparison.tree)
  tree.size <- length(reference.tree$tip.label)
  
  # calculate number of SPR vector
  n.sprs <- round(tree.size * spr.proportions)

  # iterate through each spr number
  for (sprs in n.sprs){
    # copy trees locally
    tree1 <- reference.tree
    tree2 <- comparison.tree
    # initialice vector to store congruence distribution
    congruence.distribution <- c()
    # iteratively spr trees
    for (i in 1:iterations){
      # copy trees for 0 sprs
      if (sprs == 0){
        tree1.div <- tree1
        tree2.div <- tree2
      } else {
        # spr reference tree
        tree1.div <- phangorn::rSPR(tree1, moves = sprs)
        # spr comparison tree
        tree2.div <- phangorn::rSPR(tree2, moves = sprs)
      }
      # compare comgruence
      # RF
      if (metric == 'RF') {
        congruence <- TreeDist::RobinsonFoulds(tree1.div, tree2.div)
      }
      # ICRF
      if (metric == 'ICRF') {
        congruence <- TreeDist::InfoRobinsonFoulds(tree1.div, tree2.div)
      }
      # JRF
      if (metric == 'JRF') {
        congruence <- TreeDist::JaccardRobinsonFoulds(tree1.div, tree2.div)
      }
      # MSD
      if (metric == 'MSD') {
        congruence <- TreeDist::MatchingSplitDistance(tree1.div, tree2.div)
      }
      # MSID
      if (metric == 'MSID') {
        congruence <- TreeDist::MatchingSplitInfoDistance(tree1.div, tree2.div)
      }
      # MCI
      if (metric == 'MCI') {
        congruence <- TreeDist::MutualClusteringInfo(tree1.div, tree2.div)
      }
      # SPI
      if (metric == 'SPI') {
        congruence <- TreeDist::SharedPhylogeneticInfo(tree1.div, tree2.div)
      }
      # SPI
      if (metric == 'NS') {
        congruence <- TreeDist::NyeSimilarity(tree1.div, tree2.div)
      }
      
      # save congruence to distribution
      congruence.distribution <- c(congruence, congruence.distribution)
    }
    
    # calculate integrated p value
    # for each congruence value, calculate how many null values are >= 
    p.values <- sapply(congruence.distribution, function(c.value) {
      if (metric %in% c('RF', 'ICRF', 'JRF', 'MSD', 'MSID')) {
        return(mean(null.congruence.model <= c.value))
      } else if (metric %in% c('MCI', 'SPI', 'NS')) {
        return(mean(null.congruence.model >= c.value))
      } else {
        stop("Metric not recognized.")
      }
    })
    # integrate p.value
    p.int <- mean(p.values)
    # save
    p.ints <- c(p.ints, p.int)
  }
  # assemble output
  p.curve <- data.frame(integrated.p = p.ints, prop.div = spr.proportions)
  return(p.curve)
}
